'use strict';

<%= "// This file is automatically generated from euc-kr.js.jstp" %>

const common = require('./common');
const EOF = common.EOF;
const CONTINUE = common.CONTINUE;
const ERROR = common.ERROR;

const decodeMap = <%
	// indexes.json is from https://encoding.spec.whatwg.org/indexes.json
	let indexes = JSON.parse(require('fs').readFileSync('../../cache/indexes.json', 'utf-8'));
print(JSON.stringify(indexes["euc-kr"])); %> ;

function Decoder() {
	this.lead = 0;
}

Decoder.prototype.handler = function(stream, byte) {
	// Initial byte
	if (this.lead === 0) {
		if (byte === EOF) {
			return EOF;
		}
		// Map ASCII characters directly
		if (byte <= 0x7F) {
			return byte;
		}
		// 0x80 & 0xFF are invalid for euc-kr
		if (byte === 0x80 || byte === 0xFF) {
			return ERROR;
		}
		// Shift first byte
		this.lead = byte;
		return CONTINUE;
	}

	// EOF should not be encountered for incomplete shift sequence
	if (byte === EOF) {
		this.lead = 0;
		return ERROR;
	}

	if (byte >= 0x41 && byte <= 0xFE) {
		let pointer = (this.lead - 0x81) * 190 + (byte - 0x41);
		this.lead = 0;
		let codepoint = decodeMap[pointer];
		if (codepoint !== null) {
			return codepoint;
		}
	}

	this.lead = 0;
	if (byte <= 0x7F)
		stream.prepend(byte);
	return ERROR;
}

function* Encoder() {
	while (true) {
		let codepoint = yield;
		if (codepoint === -1) {
			return;
		}
		if (codepoint <= 0x7F) {
			yield codepoint;
			continue;
		}
		let pointer = decodeMap.indexOf(codepoint);
		if (pointer === -1) {
			yield - codepoint;
			continue;
		}
		let lead = ((pointer / 190) | 0) + 0x81;
		let trail = pointer % 190 + 0x41;
		yield lead;
		yield trail;
	}
};

exports.decoder = Decoder;
exports.encoder = Encoder;