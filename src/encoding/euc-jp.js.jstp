'use strict';

<%= "// This file is automatically generated from euc-jp.js.jstp" %>

const common = require('./common');
const EOF = common.EOF;
const CONTINUE = common.CONTINUE;
const ERROR = common.ERROR;

const jis0208 = require('./jis0208');
const jis0212 = <%
	// indexes.json is from https://encoding.spec.whatwg.org/indexes.json
	let indexes = JSON.parse(require('fs').readFileSync('../../cache/indexes.json', 'utf-8'));
print(JSON.stringify(indexes.jis0212)); %> ;

function Decoder() {
	this.lead = 0;
	this.jis0212 = false;
}

Decoder.prototype.handler = function(stream, byte) {
	// Initial byte
	if (this.lead === 0) {
		if (byte === EOF) {
			return EOF;
		}
		// Map ASCII characters directly
		if (byte <= 0x7F) {
			return byte;
		}
		// 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive
		// Shift first byte
		if (byte === 0x8E || byte === 0x8F || (byte >= 0xA1 && byte <= 0xFE)) {
			this.lead = byte;
			return CONTINUE;
		}
		return ERROR;
	}

	// EOF should not be encountered for incomplete shift sequence
	if (byte === EOF) {
		this.lead = 0;
		return ERROR;
	}

	// Fixed mapping
	if (this.lead === 0x8E && byte >= 0xA1 && byte <= 0xDF) {
		this.lead = 0;
		return 0xFF61 + byte - 0xA1;
	}

	// JIS0212 escape
	if (this.lead === 0x8F && byte >= 0xA1 && byte <= 0xFE) {
		this.lead = byte;
		this.jis0212 = true;
		return CONTINUE;
	}

	// Invalid
	if (!(byte >= 0xA1 && byte <= 0xFE)) {
		this.lead = 0;
		stream.prepend(byte);
		return ERROR;
	}

	// Prefix should no longer exist
	if (this.lead === 0x8E || this.lead === 0x8F) {
		this.lead = 0;
		return ERROR;
	}

	let pointer = (this.lead - 0xA1) * 94 + byte - 0xA1;
	this.lead = 0;

	let codepoint = (this.jis0212 ? jis0212 : jis0208)[pointer];
	this.jis0212 = 0;

	return codepoint === null ? ERROR : codepoint;
};

function* Encoder() {
	while (true) {
		let codepoint = yield;
		if (codepoint === -1) {
			return;
		}
		if (codepoint <= 0x7F) {
			yield codepoint;
			continue;
		}
		if (codepoint === 0x00A5) {
			yield 0x5C;
			continue;
		}
		if (codepoint === 0x203E) {
			yield 0x7E;
			continue;
		}
		if (codepoint >= 0xFF61 && codepoint <= 0xFF9F) {
			yield 0x8E;
			yield codepoint - 0xFF61 + 0xA1;
			continue;
		}
		if (codepoint === 0x2022) {
			codepoint = 0xFF0D;
		}
		let pointer = jis0208.indexOf(codepoint);
		if (pointer >= 8272 && pointer <= 8835) {
			pointer = -1;
		}
		if (pointer === -1) {
			yield - codepoint;
			continue;
		}
		let lead = ((pointer / 94) | 0) + 0xA1;
		let trail = pointer % 94 + 0xA1;
		yield lead;
		yield trail;
	}
};

exports.decoder = Decoder;
exports.encoder = Encoder;